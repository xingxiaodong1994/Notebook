1. 如何理解html语义化？
    答：
    1. 我的理解html语义化就是用恰当的html标签表示相应的内容,避免所有内容全部使用div和span。
    2. 也有利于搜索引擎识别我们网页内容。
    3. 比如我写html页面时会简要分为三大块，头部，中部和尾部。头部使用header标签，中部使用main，尾部使用footer。
    4. 对于头部，一般会显示导航条，可以使用nav标签
    5. 中部是我们页面的主要内容用main标签包裹。如果有侧边栏，使用aside标签表示。
    6. 主要内容一般几大块，每一块使用section标签包裹。
    7. 尾部一般是一些补充内容。
    8. 在具体点就是标题用h1-h6，列表用ul,li ，按钮用button ，表单用form。
2. meta viewport 是做什么用的？
   答
   1. meta viewport 主要用来防止页面缩放
   2. 写法 `<meta name="viewport" content="width=divce-width,user-scalable=no, initial-scale=1.0 ,maximum-scale=1.0 ,minimum-scale=1.0 " />`
   3. 由于一些手机在展示网页时，会用手机模拟960px,把网页缩放，来达到用手机正常显示电脑端页面的效果。
   4. 但是这样做，我们用手机看页面是会需要手指放大，然后拖动网页观看，用户体验太差。
   5. 但是我们现在写手机页面时会单独为手机写一套css,不需要它提供的页面缩放功能。
   6. 所以我写手机端页面一般默认要加这句话在防止手机端页面缩放。
3. cavans元素是干什么的？
   1. canvas标签让我们可以通过js来绘制图形。
   2. 用法
    1. 引入canvas标签`<canvas id="canvas" width="300" height="300"></canvas>`
    2. `var canvas=document.getElementById('canvas');`
    3. `var context=canvas.getContext('2d'); ` 获取画板上下文
4.  ```js
     // //描边 
     // context.strokeStyle='yellow';
     // context.strokeRect(10,10,100,100);//rectangle
     // //填充
     // context.fillStyle='blue';
     // context.fillRect(10,10,100,100);//rectangle
     // //橡皮擦
     // //context.clearRect(50,50,10,10);
     
     // context.fillStyle='red';
     // context.beginPath();
     // context.moveTo(240,240)
     // context.lineTo(300,240)
     // context.lineTo(300,300)
     // context.fill()
     ```
5. css面试押题：
   1. 盒模型是什么？
   盒模型分为两种，我们在设置
   `box-sizing:content-box; 或者box-sizing:border-box; `
    - 对于内容框content-box，我们设置
        `width:100px;padding:10px;border:1px solid red`
        在页面显示总宽度为122px;这个框中内容宽度是100px.
    - 对于border框border-box，我们设置
        `width:100px;padding:10px;border:1px solid red`
        在页面显示总宽度为100px;这个框中内容宽度是100px.这个框中内容宽度是被挤压往内缩.
    2. css reset 和 normalize.css 有什么区别？
    - css reset 是样式重置的意思，一般在开始写项目css时，我会使用它重置一些浏览器默认样式例如`*{margin:0;padding:0}`
    - normalize.css是上面css重置的一种替代方案，它的优点是，它不是傻瓜式清除所有浏览器样式，它会保留一些有用的浏览器默认样式，然后尽力使各个浏览器css样式显示一致。
    - 当我做正式项目时我会引入normalize.css库
    - 如果只是写一下小demo,我就自己写一些css reset 样式;
    3. css居中方案？
   - 内联元素居中：
    - 水平居中：`text-align:center`
    - 垂直居中：设置子元素（内联元素）`line-height`与父元素(块级)保持`height高度`一致
        ```css
        /*内联元素设置以下属性在位置上不起作用！！但是在层叠背景有效果！！*/
        width,
        height,
        padding-top,padding-bottom,
        margin-top,margin-bottom,
        border-bottom,border-top
        ```
    - 块级元素居中：
        1. 普通居中：
         水平居中 `margin-left:auto;margin-right:auto;` 
         垂直居中:
            父元素高度减去子元素高度的二分之一作为父元素的padding值
        2. flex居中：
         ```css
        parent:{
            display: flex;
            justify-content:center;
            align-items:center;
         }
         
         ``` 
        1. 绝对定位：
        ```css
        parent:{position: relative;}
        child:{
            position:absolute;
            top:50%;
            left:50%;
            transform: translate(-50%,-50%)
         }
         ``` 
        1. 绝对定位：
        ```css
        parent:{position: relative;}
        child:{
            position:absolute;
            top:0;
            left:0;
            bottom:0;
            right:0;
            margin: auto;   
         }
         ``` 
    1. 选择器优先级设定：
        1. 选择器越具体，优先级越高 id>class
        2. 同优先级后面覆盖前面
        3. `!important` 优先级最高
    2. BFC?
        `overflow:hidden;`清除浮动，让父元素包裹子元素
    3. 清除浮动？
        父元素加clearfix类
        ```css
        .clearfix::after{
            display:block;
            content:'';
            clear:both;
        }
        .clearfix{
            zoom:1;/*兼容IE*/
        }

        ```
js
1. 7种基本数据类型：`number string boolean object null undefined symbol`
2. 手写promise
   ```js
   function xxx(){
       return new Promise(function(resolve,reject){
           //进行一些异步操作
           if(xxx){
               resolve()
           }else{
               reject()
           }
       })
   }
   xxx().then(成功函数,失败函数)
   ```
   点then里面第一参数传入resolve函数实体,第二个参数传入reject函数实体.这两个函数会在异步操作执行完毕之后自动调用。
3. 手写ajax
   ```js
   let xhr=new XMLHttpRequest()
   xhr.open('post','/xxx')
   xhr.onreadyStateChange=function(){
       if(xhr.readyState===4 && xhr.status===200){
           console.log("请求发送成功")
            console.log(xhr.responseText)
       }
   }
   xhr.send('a=1&b=2')
   发送ajax请求有四个步骤
   第一个步骤：创建一个ajax实例let xxx=new XMLHttpRequest()
   第二个步骤：xxx.open()方法。在open第一个参数传入请求的方法，第二个参数传入请求的路径
   第三步：发送这个请求xxx.send(),在send中传入请求体。
   当然在发送之前我们可以通过xxx.onreadystatechange=function(){}
   来监听发送的状态。在这个监听函数中，我们首先判断xxx.readyState是否等于4
   如果等于4说明发送成功，接着我们判断xxx.status响应的状态码
   如果200-300之间或者是304说明响应成功。如果400以后说明响应失败
   响应成功之后，我们用xxx.responseText就可以接收到服务器传过来的数据
   ``` 
4. 闭包是什么？
    当我们声明一个函数f1,在函数体内部定义一个局部变量a=1;
    然后return一个函数add,在函数add中对局部变量a进行操作，比如使a=a+1;
    这样我们构建了一个闭包。我们无法直接对局部变量a进行操作，而只能通过暴露的add函数使变量a自增1。这就是一个闭包。
    我的理解闭包就是能够读取其他函数内部变量的函数，函数没有被释放，整条作用域链上的局部变量都将得到保留。
    由于在javascript语言中，只有函数内部的子函数才能读取局部变量，因此可以把闭包简单理解成定义在一个函数内部的函数。
    由于闭包会使得函数中的变量都被保存在内存中，内存消耗很大，所以不能滥用闭包，否则会造成网页的性能问题，在IE中可能导致内存泄露。解决方法时，在退出函数之前，将不使用的局部变量全部删除。
    function f1(){
	    let a=1
	    return function(){
                return a++}
    }
    let add=f1()
    add()//1
    add()//2

所以，在本质上，闭包就是将函数内部和函数外部连接的一座桥梁
1. this的指向：
    我们声明一个函数a
    1. 直接调用函数a.call(),函数内部this就是windows
    2. 在严格模式调用a.call(),函数内部this指向undefined
    3. 我们把函数a当做对象obj的一个方法,通过obj.a.call()来调用，函数内部this指向obj
    4. 当然我们也可以通过传入a.call(this)第一个参数来改变默认指向的this值
    5. 最后说两个特例当我们`new A()`new一个构造函数A的时候，这时函数内部this指向构造函数A的实例
    6. 对于箭头函数，函数内外this值不变。
2. 立即执行函数：
    我们创建一个函数，然后立即执行它。通常我们要在函数前面加一个叹号或者分号，来防止和上文产生关联出现bug.
    我们使用立即执行函数主要是为了造出一个函数作用域防止污染全局。
3. async/await语法了解吗？
   async/await,用来处理异步问题,通过async/await写法，把异步代码写成同步代码。
   用法，当我们要进行一些异步操作时，我们可以这样做，先声明一个函数function，然后在函数前面加上async关键字。然后在函数内部定义一个变量来接受异步操作的值，可以这样写
   `let a=await xx.call()`,xx是一个异步函数，我们通过await关键字就可以得到异步函数的执行结果。
4. js原型是什么？
    我先举例说一下js原型的简单理解：当我们定义一个数组a=[1,2,3]
    这时候从字面上看数组a应该只有4个key,分别是0,1,2和长度length。对应值是1,2,3和length的长度3.
    但是呢，我们却可以使用a.push()的方法,为数组插入一个值。
    那么请问push的方法是从哪里来的？答案就是数组a通过原型链找到的。
    看浏览器控制台打印出来的数组a,你会发现数组a除了上面4个key,数组a还自带一个key是`__proto__`,通过这个属性数组a可以找到它的原型,大写的Array.prototype,我们发现在这个原型对象上有push方法 :Array.prototype.push().
    实际上呢：我们定义的数组a为大写Array构造函数的一个实例
    在Array.prototype上我们绑定了许多数组的公共方法比如push,pop,join,slice等
    当我们new一个Array的实例时，在实例上就可以调用这些方法。
5. class
    class关键字用来生成一个类，在这个类里面可以定义类的属性和方法。属性写在constructor函数里，方法直接写在类里面就可以。
6.  js如何实现继承？
    1. 通过extends关键字实现继承。我举一个例子。首先我们先定义两个类
    2. ```js
        class Animal{
            constructor(){
                this.body="身体"
            }
            move(){console.log('我会跑')}
        }
        class Human extends Animal{
            
            constructor(props){
                super(props)
                this.name=props.name
            }
            useTools(){}
        }
        let person=new Human({name:"小明"})
        console.log(person)

        ```
    3. 我们也可以使用函数来模拟类，然后实现继承：
    4. ```js
        function Animal(){
            this.body="身体"
        }
        Animal.prototype.move=function(){
            console.log('我会跑')
        }
        function Human(props){
            Animal.apply(this,arguments)
            this.name=props.name
        }
        function Fn(){}
        Fn.prototype=Animal.prototype
        Human.prototype=new Fn()
        Human.prototype.xx=function(){
            console.log('我会xx')
        }
        //Human.prototype.__proto__=Animal.prototype
        
        let person=new Human({name:"小明"})
        console.log(person)

        ```
7.  深拷贝
    let obj={}
    let obj1=JSON.parse(JSON.stringifg(obj))
    此方法不支持函数，引用，undefined、RegExp、Date……
8. 如何用正则实现 string.trim() ？
 function trim(string){
     return string.replace(/^\s+|\s+$/g, '')
 }


//http
ajax:用JS发http请求，用JS接收http响应。
jsonP 通过动态创建script标签发一个get请求
CORS :后端增加一个响应头

//学习套路：先学概念，再学知识点。看官方网站！别看山寨版