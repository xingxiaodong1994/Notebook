1. 如何理解html语义化？
    答：
    1. 我的理解html语义化就是用恰当的html标签表示相应的内容,避免所有内容全部使用div和span。
    2. 也有利于搜索引擎识别我们网页内容。
    3. 比如我写html页面时会简要分为三大块，头部，中部和尾部。头部使用header标签，中部使用main，尾部使用footer。
    4. 对于头部，一般会显示导航条，可以使用nav标签
    5. 中部是我们页面的主要内容用main标签包裹。如果有侧边栏，使用aside标签表示。
    6. 主要内容一般几大块，每一块使用section标签包裹。
    7. 尾部一般是一些补充内容。
    8. 在具体点就是标题用h1-h6，列表用ul,li ，按钮用button ，表单用form。
2. meta viewport 是做什么用的？
   答
   1. meta viewport 主要用来防止页面缩放
   2. 写法 `<meta name="viewport" content="width=divce-width,user-scalable=no, initial-scale=1.0 ,maximum-scale=1.0 ,minimum-scale=1.0 " />`
   3. 由于一些手机在展示网页时，会用手机模拟960px,把网页缩放，来达到用手机正常显示电脑端页面的效果。
   4. 但是这样做，我们用手机看页面是会需要手指放大，然后拖动网页观看，用户体验太差。
   5. 但是我们现在写手机页面时会单独为手机写一套css,不需要它提供的页面缩放功能。
   6. 所以我写手机端页面一般默认要加这句话在防止手机端页面缩放。
3. cavans元素是干什么的？
   1. canvas标签让我们可以通过js来绘制图形。
   2. 用法
    1. 引入canvas标签`<canvas id="canvas" width="300" height="300"></canvas>`
    2. `var canvas=document.getElementById('canvas');`
    3. `var context=canvas.getContext('2d'); ` 获取画板上下文
4.  ```js
     // //描边 
     // context.strokeStyle='yellow';
     // context.strokeRect(10,10,100,100);//rectangle
     // //填充
     // context.fillStyle='blue';
     // context.fillRect(10,10,100,100);//rectangle
     // //橡皮擦
     // //context.clearRect(50,50,10,10);
     
     // context.fillStyle='red';
     // context.beginPath();
     // context.moveTo(240,240)
     // context.lineTo(300,240)
     // context.lineTo(300,300)
     // context.fill()
     ```
5. css面试押题：
   1. 盒模型是什么？
   盒模型分为两种，我们在设置
   `box-sizing:content-box; 或者box-sizing:border-box; `
    - 对于内容框content-box，我们设置
        `width:100px;padding:10px;border:1px solid red`
        这个框中内容宽度是100px.在页面显示总宽度为122px;
    - 对于border框border-box，我们设置
        `width:100px;padding:10px;border:1px solid red`
        这个框中内容宽度是100px.这个框中内容宽度是被挤压往内缩.在页面显示总宽度为100px;
    2. css reset 和 normalize.css 有什么区别？
    - css reset 是样式重置的意思，一般在开始写项目css时，我会使用它重置一些浏览器默认样式例如`*{margin:0;padding:0}`
    - normalize.css是上面css重置的一种替代方案，它的优点是，它不是傻瓜式清除所有浏览器样式，它会保留一些有用的浏览器默认样式，然后尽力使各个浏览器css样式显示一致。
    - 当我做正式项目时我会引入normalize.css库
    - 如果只是写一下小demo,我就自己写一些css reset 样式;
    3. css居中方案？
   - 内联元素居中：
    - 水平居中：`text-align:center`
    - 垂直居中：设置子元素（内联元素）`line-height`与父元素(块级)保持`height高度`一致
        ```css
        /*内联元素设置以下属性在位置上不起作用！！但是在层叠背景有效果！！*/
        width,
        height,
        padding-top,padding-bottom,
        margin-top,margin-bottom,
        border-bottom,border-top
        ```
    - 块级元素居中：
        1. 普通居中：
         水平居中 `margin-left:auto;margin-right:auto;` 
         垂直居中根据`(父元素高度-子元素高度)/2`，计算出子元素`margin-top`的值
         父元素高度减去子元素高度的二分之一作为父元素的padding值
        2. flex居中：
         ```css
        parent:{
            display: flex;
            justify-content:center;
            align-items:center;
         }
         
         ``` 
        3. 绝对定位：
        ```css
        parent:{position: relative;}
        child:{
            position:absolute;
            top:50%;
            left:50%;
            transform: translate(-50%,-50%)
         }
         ``` 
        4. 绝对定位：
        ```css
        parent:{position: relative;}
        child:{
            position:absolute;
            top:0;
            left:0;
            bottom:0;
            right:0;
            margin: auto;   
         }
         ``` 
    4. 选择器优先级设定：
        1. 选择器越具体，优先级越高 id>class
        2. 同优先级后面覆盖前面
        3. `!important` 优先级最高
    5. BFC?
        `overflow:hidden;`清除浮动，让父元素包裹子元素
    6. 清除浮动？
        父元素加clearfix类
        ```css
        .clearfix::after{
            display:block;
            content:'';
            clear:both;
        }
        .clearfix{
            zoom:1;/*兼容IE*/
        }

        ```
js
1. 7种基本数据类型：`number string boolean object null undefined symbol`
2. 手写promise
   ```js
   function(){
       return new Promise(function(resolve,reject){
           //进行一些异步操作
           if(xxx){
               resolve()
           }else{
               reject
           }
       })
   }
   ```
3. 手写ajax
   ```js
   let xhl=new XMLHttpRequest()
   xhl.open('post','/xxx')
   xhl.onreadyStateChange=function(){
       if(xhl.readyState===4 && xhl.status===200){
           console.log("请求发送成功")
       }
   }
   xhl.send('a=1&b=2')
   ``` 